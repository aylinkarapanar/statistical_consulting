---
title: "Example Sampling Procedure"
author: "Atakan_Akgun, Aylin Karapanar"
date: "`r Sys.Date()`"
output: html_notebook
---

```{r}
# Create three stratums
# Use city borders layer
# Put restriction so that the samples are not close to the borders
```
This notebook is an example of a stratified sampling procedure where the strata are defined by the urban green coverage. The data used in this example is extracted from Urban Atlas 2018 for Nijmegen. The data can be changed if needed by installing the data for a different city and defining its path.

Note: If the new data is to be uploaded on GitHub, please make sure to use git lfs (large file storage). 

```{bash, eval = FALSE}
# This cell will not be executed, git commands are to be executed in the terminal
# The usage example is given for the data folder for Nijmegen
# For more info: https://git-lfs.com/
git lfs install
git lfs track "NL013L3_NIJMEGEN_UA2018_v013" #track the folder as a whole
# Another option would be to track all the file names that ends with .gpkg:
# git lfs track ".gpkg"
git add .gitattributes
# With dot all of the saved changes in the tree are added, 
# if you only want to add a specific change 
git add .
git commit -m "Added data using Git LFS"
git push
```


```{r, messages = FALSE}
set.seed(1234)
library(sf)
library(dplyr)
library(ggplot2)
library(tidyr)
library(furrr)
library(purrr)
library(future)

#Start by downloading the data for Nijmegen from Copernicus 
gpkg_path <- "./Copernicus Data/NL013L3_NIJMEGEN_UA2018_v013/Data/NL013L3_NIJMEGEN_UA2018_v013.gpkg"
buffer_radius <- 100    # meters
min_distance <- 200     # meters between sites
samples_per_stratum <- 3
grid_spacing <- 200     # meters between grid points 

# Define green and blue zone codes
green_codes <- c("14100","31000","32000","21000","22000","23000","24000")
blue_codes  <- c("50000","40000")


```
```{r}
# Inspect layers
st_layers(gpkg_path)
```

```{r}
ua_full <- st_read(gpkg_path, layer = "NL013L3_NIJMEGEN_UA2018", quiet = TRUE) %>% 
  st_make_valid()

urban_core <- st_read(gpkg_path, layer = "NL013L3_NIJMEGEN_UA2018_UrbanCore", quiet = TRUE) %>% 
  st_make_valid()
urban_core <- st_transform(urban_core, st_crs(ua_full))


green_zones <- ua_full %>% filter(code_2018 %in% green_codes)
blue_zones  <- ua_full %>% filter(code_2018 %in% blue_codes)

```
```{r}
# Generate candidate points per grid

bbox <- st_bbox(urban_core)
grid_points <- st_make_grid(urban_core, cellsize = grid_spacing, what = "centers") %>%
  st_as_sf() %>%
  st_intersection(urban_core) %>%
  mutate(site_id = row_number())

cat(sprintf("%d candidate points\n", nrow(grid_points)))

```


```{r, warning = FALSE}

# Create buffers
point_buffers <- st_buffer(grid_points, dist = buffer_radius)
buffer_area <- pi * buffer_radius^2  

green_in_buffers <- st_intersection(point_buffers, green_zones)

# Calculate green area per buffer
if (nrow(green_in_buffers) > 0) {
  
  # Calculate green area per site_id
  green_summary <- green_in_buffers %>%
    mutate(area = as.numeric(st_area(.))) %>%
    st_drop_geometry() %>%
    group_by(site_id) %>%
    summarise(green_area = sum(area), .groups = "drop")
  
  # Create full data frame with all site_ids (including those with no green)
  all_site_ids <- data.frame(site_id = grid_points$site_id)
  
  quick_metrics <- all_site_ids %>%
    left_join(green_summary, by = "site_id") %>%
    mutate(
      green_area = replace_na(green_area, 0),
      green_pct = (green_area / buffer_area) * 100,
      stratum = case_when(
        green_pct < 33.3 ~ 1,
        green_pct < 66.6 ~ 2,
        TRUE ~ 3
      )
    )
  
  # Keep only the columns we need
  quick_metrics <- quick_metrics[, c("green_pct", "stratum")]
  
} else {
  # No green zones intersect any buffers
  quick_metrics <- data.frame(
    green_pct = rep(0, nrow(grid_points)),
    stratum = rep(1, nrow(grid_points))
  )
}


# Combine with grid points
candidate_sites <- grid_points %>%
  mutate(site_id = row_number()) %>%
  bind_cols(quick_metrics)

print(table(candidate_sites$stratum))
```

```{r, warning = FALSE}
# Perform stratified sampling

sample_stratum <- function(candidates, n_samples, min_dist, max_attempts = 1000) {
  if (nrow(candidates) == 0) return(NULL)
  
  selected <- candidates[0, ]
  remaining <- candidates
  attempts <- 0
  failed_attempts <- 0
  
  while (nrow(selected) < n_samples && nrow(remaining) > 0 && attempts < max_attempts) {
    attempts <- attempts + 1
    
    # Random selection from remaining
    idx <- sample(nrow(remaining), 1)
    new_site <- remaining[idx, ]
    
    # Check distance constraint
    if (nrow(selected) > 0) {
      distances <- as.numeric(st_distance(new_site, selected))
      if (any(distances < min_dist)) {
        # If too close, remove and try another point
        remaining <- remaining[-idx, ]
        failed_attempts <- failed_attempts + 1
        next
      }
    }
    
    # Site is valid
    selected <- rbind(selected, new_site)
    failed_attempts <- 0  # Reset counter on success
  }
  
  if (nrow(selected) < n_samples) {
    cat(sprintf(" Warning: Found %d of %d requested sites after %d attempts\n",
                nrow(selected), n_samples, attempts))
  }
  
  return(selected)
}

# Sample from each stratum
selected_sites <- list()

for (s in 1:3) {
  # Get the candidate points for the stratum s
  stratum_candidates <- candidate_sites %>% filter(stratum == s)
  
  selected <- sample_stratum(
    stratum_candidates,
    n_samples = samples_per_stratum,
    min_dist = min_distance,
    max_attempts = 5000
  )
  
  if (!is.null(selected) && nrow(selected) > 0) {
    selected_sites[[s]] <- selected
    cat(sprintf("  Selected %d sites\n", nrow(selected)))
  } else {
    cat(sprintf("Could not find any sites meeting distance constraint\n"))
  }
}

final_sites <- bind_rows(selected_sites)

cat(sprintf("\nTotal selected sites: %d\n", nrow(final_sites)))

```
```{r}

final_sites_summary <- final_sites %>%
  st_drop_geometry() %>%
  mutate(
    coords = st_coordinates(final_sites),
    x = coords[, 1],
    y = coords[, 2]
  ) %>%
  dplyr::select(site_id, stratum, green_pct,
         x, y) %>%
  arrange(stratum, site_id)

print(final_sites_summary)

```

```{r, warning=FALSE}
# Calculate the metrics for the selected sites


final_buffers <- st_buffer(final_sites, dist = buffer_radius)
buffer_area <- pi * buffer_radius^2


green_zones_simple <- green_zones %>% 
  dplyr::select(code_2018, class_2018)

green_intersections <- st_intersection(final_buffers, green_zones_simple)

if (nrow(green_intersections) > 0) {
  # Calculate areas and find dominant code per site
  dominant_green <- green_intersections %>%
    mutate(area = as.numeric(st_area(.))) %>%
    st_drop_geometry() %>%
    group_by(site_id, code_2018, class_2018) %>%
    summarise(total_area = sum(area), .groups = "drop") %>%
    group_by(site_id) %>%
    arrange(desc(total_area)) %>%
    slice(1) %>%
    ungroup() %>%
    dplyr::select(site_id, 
                  dominant_green_code = code_2018, 
                  dominant_green_class = class_2018)
  
} else {
  dominant_green <- data.frame(
    site_id = final_sites$site_id,
    dominant_green_code = NA_character_,
    dominant_green_class = NA_character_
  )
}


blue_intersections <- st_intersection(final_buffers, blue_zones)

if (nrow(blue_intersections) > 0) {
  blue_coverage <- blue_intersections %>%
    mutate(area = as.numeric(st_area(.))) %>%
    st_drop_geometry() %>%
    group_by(site_id) %>%
    summarise(blue_area = sum(area), .groups = "drop") %>%
    mutate(blue_pct = (blue_area / buffer_area) * 100) %>%
    dplyr::select(site_id, blue_pct)
  
} else {
  blue_coverage <- data.frame(
    site_id = final_sites$site_id,
    blue_pct = 0
  )
}


if (nrow(blue_zones) > 0) {
  # Calculate distance matrix: all sites to all blue zones
  dist_matrix <- st_distance(final_sites, blue_zones)
  
  # Get minimum distance per site
  dist_to_blue <- data.frame(
    site_id = final_sites$site_id,
    dist_to_blue = as.numeric(apply(dist_matrix, 1, min))
  )
  
} else {
  dist_to_blue <- data.frame(
    site_id = final_sites$site_id,
    dist_to_blue = NA_real_
  )
}


detailed <- data.frame(site_id = final_sites$site_id) %>%
  left_join(dominant_green, by = "site_id") %>%
  left_join(blue_coverage, by = "site_id") %>%
  left_join(dist_to_blue, by = "site_id") %>%
  mutate(
    blue_pct = replace_na(blue_pct, 0),
    dominant_green_code = as.character(dominant_green_code),
    dominant_green_class = as.character(dominant_green_class)
  ) %>%
  dplyr::select(-site_id)  


# Combine with final sites
final_sites <- final_sites %>% bind_cols(detailed)

```

```{r}

# Extract coordinates in original CRS
coords_3035 <- st_coordinates(final_sites)

# Transform to WGS84 for GPS coordinates
final_sites_wgs84 <- st_transform(final_sites, 4326)
coords_wgs84 <- st_coordinates(final_sites_wgs84)

final_sites_summary <- final_sites %>%
  st_drop_geometry() %>%
  mutate(
    x_epsg3035 = coords_3035[, 1],
    y_epsg3035 = coords_3035[, 2],
    longitude = coords_wgs84[, 1],
    latitude = coords_wgs84[, 2]
  ) %>%
  dplyr::select(site_id, stratum, 
         longitude, latitude,
         x_epsg3035, y_epsg3035,
         green_pct, blue_pct, dist_to_blue,
         dominant_green_code, dominant_green_class) %>%
  arrange(stratum, site_id)

print(final_sites_summary, n = Inf)


# Save as CSV 
write.csv(final_sites_summary, 
          file.path("./Simulated Data/nijmegen_sites_coordinates.csv"),
          row.names = FALSE)

```

```{r}
other_zones <- ua_full %>%
  filter(!code_2018 %in% c(green_codes, blue_codes)) %>%
  st_intersection(urban_core)

ua_full_core <- st_intersection(ua_full, urban_core)

green_zones_core <- st_intersection(green_zones, urban_core)
blue_zones_core  <- st_intersection(blue_zones, urban_core)

other_zones_core <- ua_full_core %>%
  filter(!code_2018 %in% c(green_codes, blue_codes))


site_buffers <- final_sites %>%
  st_buffer(dist = buffer_radius)

land_use_labels <- c(
  "14100" = "Green urban areas",
  "31000" = "Forests",
  "32000" = "Herbaceous vegetation",
  "21000" = "Arable land",
  "22000" = "Permanent crops",
  "23000" = "Pastures",
  "24000" = "Complex cultivation"
)


p <- ggplot() +
  # Grey base map (all non-green/blue land use)
  geom_sf(data = other_zones_core, fill = "grey85",
          color = "grey70", linewidth = 0.1, alpha = 0.8) +

  # Green zones inside the core
  geom_sf(data = green_zones_core, aes(fill = code_2018),
          color = "darkgreen", linewidth = 0.2, alpha = 0.7) +

  # Blue zones inside the core
  geom_sf(data = blue_zones_core, fill = "lightblue",
          color = "blue", linewidth = 0.2, alpha = 0.7) +

  # Buffer rings around sites
  geom_sf(data = site_buffers, aes(color = as.factor(stratum)),
          fill = NA, linewidth = 1) +

  # Sampled sites
  geom_sf(data = final_sites, aes(fill = as.factor(stratum)),
          color = "white", size = 4, shape = 21, stroke = 0.5) +

  scale_fill_manual(
    name = "Land Use Types",
    values = c(
      "14100" = "#9FDF9F", 
      "31000" = "#1A6B00",  
      "32000" = "#C3E68C",  
      "21000" = "#FFFFCC", 
      "22000" = "#F5B77B", 
      "23000" = "#FFFF00",  
      "24000" = "#FFFFB2",
      "1" = "#d7191c",
      "2" = "#fdae61",
      "3" = "#5e3c99"
    ),
    breaks = green_codes,
    labels = land_use_labels[green_codes],
    na.translate = FALSE,
    guide = guide_legend(order = 1, override.aes = list(shape = NA))
  ) +

  scale_color_manual(
    name = "Green Coverage",
    values = c(
      "1" = "#d7191c",
      "2" = "#fdae61",
      "3" = "#5e3c99"
    ),
    labels = c(
      "1" = "0–33%",
      "2" = "33–66%",
      "3" = "66–100%"
    ),
    guide = guide_legend(
      order = 2,
      override.aes = list(
        fill = c("#d7191c", "#fdae61", "#5e3c99"),
        color = "white",
        shape = 21,
        size = 4,
        stroke = 0.5
      )
    )
  ) +

  labs(
    title = "Stratified Sampling Sites – Nijmegen Urban Core (UA 2018)",
    x = NULL,
    y = NULL
  ) +

  theme_minimal(base_size = 11) +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold", size = 14, margin = margin(b = 5)),
    axis.text = element_text(size = 8, color = "grey40"),
    panel.grid.minor = element_blank()
  )


p
```
```{r}
# Save plot
ggsave(file.path("./Simulated Data/nijmegen_sampling_map.png"),
       plot = p, width = 14, height = 10, dpi = 300)
```

```{r}

summary_stats <- final_sites %>%
  st_drop_geometry() %>%
  group_by(stratum) %>%
  summarise(
    n = n(),
    mean_green = mean(green_pct, na.rm = TRUE),
    mean_blue = mean(blue_pct, na.rm = TRUE),
    mean_dist_blue = mean(dist_to_blue, na.rm = TRUE),
    .groups = "drop"
  )

print(summary_stats)

final_sites %>%
  st_drop_geometry() %>%
  filter(!is.na(dominant_green_class)) %>%
  group_by(stratum, dominant_green_class) %>%
  summarise(count = n(), .groups = "drop") %>%
  arrange(stratum, desc(count)) %>%
  print(n = Inf)


```




